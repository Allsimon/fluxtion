## Velocity Template.
package ${functionPackage};
#foreach( $import in $imports)
import $import;
#end

/**
 * Generated mapper function wrapper for a reference type.
 *<ul>
 * <li>output class       : {@link ${outputClass}}
 * <li>input class        : {@link ${filterSubjectClass}}
 * <li>converter function : {@link ${targetClass}#${targetMethod}}
 *</ul>
 * 
 * @author Greg Higgins
 */
public class ${functionClass} implements Wrapper<${outputClass}>{

    public ${sourceClass} filterSubject;
#if(!${newFunction})
    @NoEventReference
    public ${targetClass} f;
#end
    private ${outputClass} result;
#if(${stateful})
    @NoEventReference
    public Object resetNotifier;
#end
    private boolean notifyOnChangeOnly = false;

    @Initialise
    public void init(){
        result = null;
    }

    @OnEvent
    public boolean onEvent(){
        ${outputClass} oldValue = result;
#if(${newFunction})
        result = ${targetClass}.${targetMethod}(${input});
#else
        result = f.${targetMethod}(${input});
#end
        return !notifyOnChangeOnly || (!oldValue.equals(result));
    }
#if(${stateful})

    @OnParentUpdate("resetNotifier")
    public void resetNotification(Object resetNotifier){
        result = null;
        f.reset();
    }

    @Override
    public Wrapper<${outputClass}> resetNotifier(Object resetNotifier) {
        this.resetNotifier = resetNotifier;
        return this;
    }
#end

    @Override
    public Wrapper<${outputClass}> notifyOnChange(boolean notifyOnChange){
        this.notifyOnChangeOnly = notifyOnChange;
        return this;
    }

    public boolean isNotifyOnChangeOnly() {
        return notifyOnChangeOnly;
    }

    public void setNotifyOnChangeOnly(boolean notifyOnChangeOnly) {
        this.notifyOnChangeOnly = notifyOnChangeOnly;
    }

    @Override
    public ${outputClass} event() {
        return result;
    }

    @Override
    public Class<${outputClass}> eventClass() {
        return ${outputClass}.class;
    }
}

